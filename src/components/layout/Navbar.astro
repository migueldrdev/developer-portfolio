---
// --- SERVER SIDE (Astro) ---
import NavbarElement from "@components/layout/NavbarElement.astro";
import DropDown from "@components/layout/DropDown.astro";
import DarkModeToggle from "@components/layout/DarkModeToggle.astro";
import type { Menu } from "@interfaces/Menu";

// Definimos las props esperadas
interface Props {
  menu: Menu[];
}

const { menu = [] } = Astro.props;
---

<nav
  class="fixed w-full z-20 top-0 start-0 border-b border-transparent transition-all duration-150"
>
  <div
    id="navbar"
    class="flex flex-wrap items-center justify-end md:justify-center p-4 md:my-2 md:px-4 md:py-1.5 mx-auto md:max-w-xl md:rounded-xl rtl:space-x-reverse"
  >
    <div
      class="flex items-center space-x-3 md:space-x-0 md:order-2 rtl:space-x-reverse"
    >
      <DarkModeToggle />

      <button
        data-collapse-toggle="navbar-sticky"
        type="button"
        class="inline-flex items-center p-2 justify-center text-sm rounded-lg md:hidden bg-gray-100 text-gray-700 hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600 dark:focus:ring-gray-600 transition-colors"
        aria-controls="navbar-sticky"
        aria-expanded="false"
      >
        <span class="sr-only">Abrir menú principal</span>
        <svg
          class="w-5 h-5"
          aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 17 14"
        >
          <path
            stroke="currentColor"
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M1 1h15M1 7h15M1 13h15"></path>
        </svg>
      </button>
    </div>

    <div
      class="items-center justify-between hidden w-full md:flex md:w-auto md:order-1"
      id="navbar-sticky"
    >
      <ul
        class="flex flex-col w-full font-medium p-4 md:p-0 mt-4 md:mt-0 bg-gray-50 border border-gray-100 rounded-lg md:bg-transparent md:space-x-8 rtl:space-x-reverse md:flex-row md:border-0 dark:bg-gray-800 md:dark:bg-transparent dark:border-gray-700"
      >
        {
          menu.map((item: Menu) => {
            // Lógica de renderizado condicional (Dropdown o Link normal)
            return item.items && item.items.length > 0 ? (
              <li>
                <DropDown label={item.label} items={item.items} />
              </li>
            ) : (
              <NavbarElement {...item} />
            );
          })
        }
      </ul>
    </div>
  </div>
</nav>

<script>
  import { onPageReady } from "@utils/lifecycle";
  // --- CONSTANTES Y TIPOS ---

  // Clases para el estilo activo de los enlaces
  const activeClasses = [
    "text-white",
    "bg-blue-700",
    "md:bg-transparent",
    "md:text-blue-700",
    "md:dark:text-blue-500",
  ];

  // Clases para el navbar cuando hace scroll (fondo sólido)
  const scrolledClasses = [
    "bg-white",
    "dark:bg-gray-900",
    "border-gray-200",
    "dark:border-gray-600",
    "shadow-md",
  ];

  // --- FUNCIONES PRINCIPALES ---

  /**
   * Maneja el aspecto del navbar al hacer scroll (transparente -> sólido)
   */
  const handleNavbarAppearance = (): void => {
    const navbar = document.getElementById("navbar");
    if (!navbar) return;

    if (window.scrollY > 20) {
      navbar.classList.add(...scrolledClasses);
      navbar.classList.remove("border-transparent");
    } else {
      navbar.classList.remove(...scrolledClasses);
      navbar.classList.add("border-transparent");
    }
  };

  /**
   * Detecta qué sección está visible y activa el enlace correspondiente
   */
  const handleScrollSpy = (): void => {
    const sections = document.querySelectorAll<HTMLElement>(".scroll-section");
    const navLinks =
      document.querySelectorAll<HTMLAnchorElement>("nav a.nav-link");

    // Offset para compensar la altura del header fijo
    const headerOffset = 80;
    const scrollPos = window.scrollY;

    let currentSectionId: string | null = null;

    // Recorremos secciones de abajo hacia arriba para encontrar la activa
    // (Convertimos NodeList a Array para usar reverse o for loop normal)
    for (let i = sections.length - 1; i >= 0; i--) {
      const section = sections[i];
      const sectionTop = section.offsetTop - headerOffset;
      const sectionBottom = sectionTop + section.offsetHeight;

      if (scrollPos >= sectionTop && scrollPos < sectionBottom) {
        currentSectionId = section.id;
        break;
      }
    }

    // Caso especial: Si estamos muy arriba, activar la primera sección
    if (
      currentSectionId === null &&
      sections.length > 0 &&
      scrollPos < sections[0].offsetTop + sections[0].offsetHeight / 2
    ) {
      currentSectionId = sections[0].id;
    }

    // Actualizamos clases y URL
    navLinks.forEach((link) => {
      const href = link.getAttribute("href");
      if (!href) return;

      // Extraer ID desde la URL limpia: "/" -> "home", "/skills" -> "skills"
      const linkId = href === "/" ? "home" : href.substring(1);

      if (linkId === currentSectionId) {
        link.classList.add(...activeClasses);
        link.setAttribute("aria-current", "page");
        
        // Actualizar URL del navegador solo si es diferente (sin recargar)
        const currentPath = window.location.pathname;
        if (currentPath !== href) {
          window.history.replaceState({ section: linkId }, "", href);
        }
      } else {
        link.classList.remove(...activeClasses);
        link.removeAttribute("aria-current");
      }
    });
  };

  /**
   * Maneja el clic en el botón hamburguesa (Móvil)
   */
  const initMobileMenu = (): void => {
    const collapseBtn = document.querySelector<HTMLButtonElement>(
      '[data-collapse-toggle="navbar-sticky"]'
    );
    const collapseTarget = document.getElementById("navbar-sticky");

    if (collapseBtn && collapseTarget) {
      // Limpiamos listeners anteriores para evitar duplicados en view transitions
      const newBtn = collapseBtn.cloneNode(true) as HTMLButtonElement;
      collapseBtn.parentNode?.replaceChild(newBtn, collapseBtn);

      newBtn.addEventListener("click", () => {
        const isHidden = collapseTarget.classList.contains("hidden");
        collapseTarget.classList.toggle("hidden", !isHidden); // Toggle hidden
        collapseTarget.classList.toggle("flex", isHidden); // Toggle flex
        newBtn.setAttribute("aria-expanded", (!isHidden).toString());
      });
    }
  };

  /**
   * Configura el Smooth Scroll para enlaces internos con URLs limpias (sin #)
   * Usa History API para mantener URLs profesionales
   */
  const initSmoothScroll = (): void => {
    // Seleccionar enlaces internos (que empiezan con / y son de la misma página)
    document
      .querySelectorAll<HTMLAnchorElement>('nav a.nav-link')
      .forEach((anchor) => {
        anchor.addEventListener("click", function (e) {
          e.preventDefault();
          const href = this.getAttribute("href");
          if (!href) return;

          // Extraer el ID de la sección desde la URL
          // "/" -> "home", "/skills" -> "skills"
          const targetId = href === "/" ? "home" : href.substring(1);
          const targetElement = document.getElementById(targetId);

          if (targetElement) {
            const headerOffset = 80;
            const elementPosition = targetElement.getBoundingClientRect().top;
            const offsetPosition =
              elementPosition + window.scrollY - headerOffset;

            // Scroll suave a la sección
            window.scrollTo({
              top: offsetPosition,
              behavior: "smooth",
            });

            // Actualizar URL usando History API
            window.history.pushState({ section: targetId }, "", href);

            // Cerrar menú móvil si está abierto
            const collapseTarget = document.getElementById("navbar-sticky");
            if (
              collapseTarget &&
              !collapseTarget.classList.contains("hidden")
            ) {
              collapseTarget.classList.add("hidden");
              collapseTarget.classList.remove("flex");
            }
          }
        });
      });
  };

  /**
   * Maneja la navegación con botones atrás/adelante del navegador
   */
  const handleBrowserNavigation = (): void => {
    window.addEventListener("popstate", (event) => {
      if (event.state && event.state.section) {
        const targetElement = document.getElementById(event.state.section);
        if (targetElement) {
          const headerOffset = 80;
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition =
            elementPosition + window.scrollY - headerOffset;

          window.scrollTo({
            top: offsetPosition,
            behavior: "smooth",
          });
        }
      } else {
        // Si no hay state, ir al inicio
        window.scrollTo({ top: 0, behavior: "smooth" });
      }
    });
  };

  /**
   * Maneja la navegación inicial cuando se carga la página con una ruta específica
   * Ejemplo: si cargas /skills directamente, hace scroll a esa sección
   */
  const handleInitialNavigation = (): void => {
    const currentPath = window.location.pathname;
    
    // Si no es la raíz, intentar scroll a la sección correspondiente
    if (currentPath !== '/') {
      const sectionId = currentPath.substring(1); // /skills -> skills
      const targetElement = document.getElementById(sectionId);
      
      if (targetElement) {
        // Pequeño delay para asegurar que el DOM está listo
        setTimeout(() => {
          const headerOffset = 80;
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.scrollY - headerOffset;
          
          window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth',
          });
        }, 100);
      }
    }
  };

  // --- INICIALIZACIÓN MAESTRA ---

  const initNavbar = (): void => {
    // 1. Ejecutar lógica inicial
    handleNavbarAppearance();
    handleScrollSpy();
    initMobileMenu();
    initSmoothScroll();
    handleBrowserNavigation();
    handleInitialNavigation();

    // 2. Event Listener para Scroll (Optimizado con requestAnimationFrame)
    let ticking = false;
    const onScroll = () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          handleNavbarAppearance();
          handleScrollSpy();
          ticking = false;
        });
        ticking = true;
      }
    };

    // Removemos listener previo si existe (buena práctica en SPA/Astro)
    window.removeEventListener("scroll", onScroll);
    window.addEventListener("scroll", onScroll);
  };

  // Ejecutar al cargar
  initNavbar();

  // Soporte para View Transitions (Navegación SPA de Astro)
  onPageReady(initNavbar);
</script>
